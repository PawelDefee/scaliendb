
- go through TODOs

- one or more PaxosLease instances? - one or more ReplicatedLog instances?
  + we need MANY because of timers
- contextID vs. logID vs. chunkID

- writev vectored write optimalizations

- change * and & to conform to Doom3 standards

- Readf/Writef vs ReadBuffer

- PaxosAcceptorState::value should come from a BufferPool (!)

- Paxos value should have a limit of 100K (=object size limit),
  but this should not limit the KV value size
  eg. a large value is typically a list, but only replicate the small mutation ops
  which involve one object at a time

- data node's ReplicatedLog should only send "header" to control nodes
  does this mean we need two different ReplicatedLog implementations?

- catchup now asks the sender to send the chosen value
  this won't work for chunk replication if the server is a controller

- when a chunk is taken away from a data node, it needs to shut down that
  QuorumContext/ReplicatedLog, so we'll need a Shutdown() function there
  problem is if there are async (db) operations going on for that chunk

- stremaing ReplicatedLog catchup

- transaction juggling

+ I think epochID is unnecessary


data:
-----
- if not exists: create db
- context with contextID 1
- register with controllers
- ChunkDB: GET / SET
- HTTP 


controller:
-----------
- PaxosLease (ControlConfigContext)
- ControlDB
- ChunkDB[logID=1]
- if receive message from node n with logID l:
	- if l == 0: SPECIAL CASE, register node
	- else: check if node n is part of context l
		- yes: Paxos
		- no: drop message
- periodically inform data nodes who the primary is
//- periodically inform data nodes who the controller master is
- HTTP



- Get in SortedList
- get rid of function consts










#include <stdio.h>

#include "Application/HTTP/HttpServer.h"
#include "Application/HTTP/HttpConsts.h"
#include "System/Events/EventLoop.h"
#include "System/Containers/HashTable.h"

size_t Hash(const char* str)
{
	size_t h;
	unsigned char *p;
	
	h = 0;
	for (p = (unsigned char *)str; *p != '\0'; p++)
		h = 37 * h + *p;
		
	return h;
}

class SimpleHandler : public HttpHandler
{
public:
	virtual bool	HandleRequest(HttpConn* conn, const HttpRequest& request);
};

bool SimpleHandler::HandleRequest(HttpConn* conn, const HttpRequest& /*request*/)
{
	conn->Response(HTTP_STATUS_CODE_OK, "hello", 5);
	return true;
}

int main(void)
{
//	configFile.Init("");
	
	HttpServer		httpServer;
	SimpleHandler	handler;
	HashTable<const char*, const char*> testHash;
	const char**	pvalue;
		
	Log_SetTarget(LOG_TARGET_STDOUT);
	Log_SetTrace(true);
	Log_SetTimestamping(true);
	
	testHash.Set("hello", "world");
	testHash.Set("hol", "peru");
	pvalue = testHash.Get("hol");
	if (pvalue)
		Log_Trace("hol = %s", *pvalue);
	
	IOProcessor::Init(1024);
	
	httpServer.Init(8080);
	httpServer.RegisterHandler(&handler);

	EventLoop::Init();
	EventLoop::Run();
	EventLoop::Shutdown();
}



