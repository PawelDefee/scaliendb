
- go through TODOs

- one or more PaxosLease instances? - one or more ReplicatedLog instances?
  + we need MANY because of timers
- contextID vs. logID vs. chunkID

- writev vectored write optimalizations

- change * and & to conform to Doom3 standards

- Readf/Writef vs ReadBuffer

- PaxosAcceptorState::value should come from a BufferPool (!)

- Paxos value should have a limit of 100K (=object size limit),
  but this should not limit the KV value size
  eg. a large value is typically a list, but only replicate the small mutation ops
  which involve one object at a time

- data node's ReplicatedLog should only send "header" to control nodes
  does this mean we need two different ReplicatedLog implementations?

- catchup now asks the sender to send the chosen value
  this won't work for chunk replication if the server is a controller

- when a chunk is taken away from a data node, it needs to shut down that
  QuorumContext/ReplicatedLog, so we'll need a Shutdown() function there
  problem is if there are async (db) operations going on for that chunk

- stremaing ReplicatedLog catchup

- transaction juggling

+ I think epochID is unnecessary


data:
-----
- if not exists: create db
- context with contextID 1
- register with controllers
- ChunkDB: GET / SET
- HTTP 


controller:
-----------
- PaxosLease (ConfigContext)
- ControlDB
- ChunkDB[logID=1]
- if receive message from node n with logID l:
	- if l == 0: SPECIAL CASE, register node
	- else: check if node n is part of context l
		- yes: Paxos
		- no: drop message
- periodically inform data nodes who the primary is
//- periodically inform data nodes who the controller master is
- HTTP


NOW:
- get rid of MessageWriter style prefix in Write
  instead have Messages know about contextID by context->GetContextID()

- Get in SortedList
- get rid of function consts










#include <stdio.h>

#include "Application/HTTP/HttpServer.h"
#include "Application/HTTP/HttpConsts.h"
#include "System/Events/EventLoop.h"
#include "System/Containers/HashTable.h"

size_t Hash(const char* str)
{
	size_t h;
	unsigned char *p;
	
	h = 0;
	for (p = (unsigned char *)str; *p != '\0'; p++)
		h = 37 * h + *p;
		
	return h;
}

class SimpleHandler : public HttpHandler
{
public:
	virtual bool	HandleRequest(HttpConn* conn, const HttpRequest& request);
};

bool SimpleHandler::HandleRequest(HttpConn* conn, const HttpRequest& /*request*/)
{
	conn->Response(HTTP_STATUS_CODE_OK, "hello", 5);
	return true;
}

int main(void)
{
//	configFile.Init("");
	
	HttpServer		httpServer;
	SimpleHandler	handler;
	HashTable<const char*, const char*> testHash;
	const char**	pvalue;
		
	Log_SetTarget(LOG_TARGET_STDOUT);
	Log_SetTrace(true);
	Log_SetTimestamping(true);
	
	testHash.Set("hello", "world");
	testHash.Set("hol", "peru");
	pvalue = testHash.Get("hol");
	if (pvalue)
		Log_Trace("hol = %s", *pvalue);
	
	IOProcessor::Init(1024);
	
	httpServer.Init(8080);
	httpServer.RegisterHandler(&handler);

	EventLoop::Init();
	EventLoop::Run();
	EventLoop::Shutdown();
}


	// A.
	// a shard is HEALTHY if
	// enough quorum members are assigned
	// all quorum members are up
	// primary lease is active

	// B.
	// never split a shard that is not HEALTHY

	// C.
	// never remove the last node from a quorum
	// => if a shard's quorum has zero members, that means it's a table's first
	// and has not been assigned yet

	// D. (do this later)
	// how to make sure there is only one PRIMARY
	// the MASTER sends a PRIMARY lease
	// the PRIMARY sends its PRIMARY lease along with the first message it replicates
	// all other nodes receive it and start timers
	// the other nodes will refuse to become masters as long as their timers are active

	// 1.
	// for each shard
	// if some quorum members are assigned
	// if all quorum members are up
	// and no primary lease is active
	// ACTION: give out lease to the primary
	// TRIGGER EVENT: last quorum member signs in
	// or
	// TRIGGER EVENT: previous lease should be renewed
	
	// 2.
	// for each shard
	// if no quorum members are assigned
	// look for the max. number of servers that are available,
	// no less than the replication target!
	// ACTION: and create the quorum
	// TRIGGER EVENT: new table is created
	// 1. will cause it to receive a PRIMARY lease
	
	// 3.
	// for each shard
	// if some quorum members are assigned
	// but one of them is not alive
	// ACTION: decrease quorum
	// TRIGGER EVENT: shard doesn't report in in N secods
	
	// 4. (do this later)
	// for each shard
	// if quorum members are assigned
	// but not enough to meet the replication target
	// and a shard server is reporting it has an almost-up-to-date version
	// and nobody is currently catching up on that shard
	// start process which joins the shard server into the quorum:
	// next time, give out the lease to the primary with the new quorum
	// then, if primary reports progress, add the shard server to the quorum "officially"
	// TRIGGER EVENT: shard server reports in
		
	// 5. (do this later)
	// if quorum members are assigned
	// but not enought to meet the replication target
	// and no shard server is reporting it has an almost-up-to-date version
	// then tell a new shard server to catch up
	
	// 6. (do this later)
	// if a shard server reports a shard
	// but the shard server is not part of the quorum
	// and the replication target is met, then tell it to delete the shard
	
	// 7. (do this later)
	// if a shard server reports a shard
	// but the shard server is not part of the quorum
	// and its versionID is behind, then tell it to delete the shard

	// 8. (rebalancing)
	// remove old one from quorum
	// tell it to delete the shard
	// 5. => will trigger



